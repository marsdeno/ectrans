


MODULE CUDA_COPY_MODULE

USE OPENACC
USE CUDAFOR
USE ISO_C_BINDING



IMPLICIT NONE

PRIVATE

PUBLIC :: COPY, NH2D, ND2H, ACC_HANDLE_KIND

INTEGER(4), PARAMETER :: NH2D = CUDAMEMCPYHOSTTODEVICE , ND2H = CUDAMEMCPYDEVICETOHOST

INTERFACE COPY
MODULE PROCEDURE COPY_2_REAL_4
MODULE PROCEDURE COPY_2_REAL_8
MODULE PROCEDURE COPY_3_REAL_4
MODULE PROCEDURE COPY_3_REAL_8
MODULE PROCEDURE COPY_4_REAL_4
MODULE PROCEDURE COPY_4_REAL_8
END INTERFACE

CONTAINS


  SUBROUTINE COPY_2_REAL_4(DST, SRC, KDIR, QUEUE)
    REAL(4), TARGET :: DST(:,:), SRC(:,:)
    REAL(4), POINTER :: DST_PTR(:,:), SRC_PTR(:,:)
    INTEGER (KIND=4), INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC

    SRC_PTR => SRC
    DST_PTR => DST

    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_4(SRC_PTR, 0)
    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_4(DST_PTR, 0)

    IF (LAST_CONTIG_DIM_SRC == 2 .AND. LAST_CONTIG_DIM_DST == 2) THEN
      CALL COPY_2_REAL_4_1D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ELSE
      CALL COPY_2_REAL_4_2D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_2_REAL_4_1D(DST, SRC, KDIR, QUEUE)
    REAL(4), CONTIGUOUS, POINTER :: DST (:,:), SRC (:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE

    INTEGER (KIND=C_SIZE_T) :: ISIZE

    ISIZE = KIND (DST) * SIZE(DST(:,:), KIND=C_SIZE_T)

    IF (KDIR == NH2D) THEN
      !$ACC HOST_DATA USE_DEVICE(DST)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_TO_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_TO_DEVICE(DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_FROM_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_FROM_DEVICE (DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ENDIF

  END SUBROUTINE
  SUBROUTINE COPY_2_REAL_4_2D(DST, SRC, KDIR, QUEUE)
    REAL(4), POINTER :: DST (:,:), SRC (:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC
    INTEGER :: NEXT_CONTIG_DIM_DST, NEXT_CONTIG_DIM_SRC

    INTEGER :: LAST_CONTIG_DIM

    INTEGER :: IRET
    INTEGER :: IPITCH_DST, IPITCH_SRC
    INTEGER(KIND=C_SIZE_T) :: IWIDTH, IHEIGHT, ISHP_SRC(3), ISHP_DST(3)
    INTEGER(KIND=C_SIZE_T) :: ISTRIDES_SRC(3), ISTRIDES_DST(3)
    INTEGER(KIND=CUDA_STREAM_KIND) :: STREAM
    TYPE(C_PTR) :: HSTPTR
    TYPE(C_DEVPTR) :: DEVPTR

    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_4(DST, 0)
    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_4(SRC, 0)
    NEXT_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_4(DST, LAST_CONTIG_DIM_DST+1)
    NEXT_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_4(SRC, LAST_CONTIG_DIM_SRC+1)

    ! We expect that device is always contiguous, and that host has only one non-contiguous dimension
    IF (KDIR == NH2D) THEN
      IF (LAST_CONTIG_DIM_DST /= 2) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_SRC /= 2) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_SRC
    ELSE IF (KDIR == ND2H) THEN
      IF (LAST_CONTIG_DIM_SRC /= 2) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_DST /= 2) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_DST
    ENDIF


    ISTRIDES_SRC(1) = LOC (SRC(LBOUND(SRC, 1)+1, LBOUND(SRC, 2))) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2)))
    ISTRIDES_DST(1) = LOC (DST(LBOUND(DST, 1)+1, LBOUND(DST, 2))) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2)))

    ISTRIDES_SRC(2) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2)+1)) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2)))
    ISTRIDES_DST(2) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2)+1)) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2)))

    ISTRIDES_SRC(3) = ISTRIDES_SRC(2) * SIZE(SRC, 2)
    ISTRIDES_DST(3) = ISTRIDES_DST(2) * SIZE(DST, 2)

    ISHP_SRC(1) = 1
    ISHP_SRC(2:) = SHAPE(SRC)
    ISHP_DST(1) = 1
    ISHP_DST(2:) = SHAPE(DST)
    IWIDTH = PRODUCT(ISHP_DST(1:LAST_CONTIG_DIM+1)) * KIND(DST)
    IHEIGHT = PRODUCT(ISHP_DST(LAST_CONTIG_DIM+2:NEXT_CONTIG_DIM_SRC+1))

    IPITCH_SRC = ISTRIDES_SRC(LAST_CONTIG_DIM+1)
    IPITCH_DST = ISTRIDES_DST(LAST_CONTIG_DIM+1)

    IF (KDIR == NH2D) THEN
      HSTPTR = C_LOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2)))
      !$ACC HOST_DATA USE_DEVICE(DST)
      DEVPTR = C_DEVLOC(DST(LBOUND(DST, 1),LBOUND(DST, 2)))
      !$ACC END HOST_DATA
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(DEVPTR, IPITCH_DST, &
                               & HSTPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(DEVPTR, IPITCH_DST, &
                          & HSTPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in H2D")
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      DEVPTR = C_DEVLOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2)))
      !$ACC END HOST_DATA
      HSTPTR = C_LOC(DST(LBOUND(DST, 1),LBOUND(DST, 2)))
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(HSTPTR, IPITCH_DST, &
                               & DEVPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(HSTPTR, IPITCH_DST, &
                          & DEVPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in D2H")
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_2_REAL_8(DST, SRC, KDIR, QUEUE)
    REAL(8), TARGET :: DST(:,:), SRC(:,:)
    REAL(8), POINTER :: DST_PTR(:,:), SRC_PTR(:,:)
    INTEGER (KIND=4), INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC

    SRC_PTR => SRC
    DST_PTR => DST

    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_8(SRC_PTR, 0)
    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_8(DST_PTR, 0)

    IF (LAST_CONTIG_DIM_SRC == 2 .AND. LAST_CONTIG_DIM_DST == 2) THEN
      CALL COPY_2_REAL_8_1D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ELSE
      CALL COPY_2_REAL_8_2D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_2_REAL_8_1D(DST, SRC, KDIR, QUEUE)
    REAL(8), CONTIGUOUS, POINTER :: DST (:,:), SRC (:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE

    INTEGER (KIND=C_SIZE_T) :: ISIZE

    ISIZE = KIND (DST) * SIZE(DST(:,:), KIND=C_SIZE_T)

    IF (KDIR == NH2D) THEN
      !$ACC HOST_DATA USE_DEVICE(DST)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_TO_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_TO_DEVICE(DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_FROM_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_FROM_DEVICE (DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ENDIF

  END SUBROUTINE
  SUBROUTINE COPY_2_REAL_8_2D(DST, SRC, KDIR, QUEUE)
    REAL(8), POINTER :: DST (:,:), SRC (:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC
    INTEGER :: NEXT_CONTIG_DIM_DST, NEXT_CONTIG_DIM_SRC

    INTEGER :: LAST_CONTIG_DIM

    INTEGER :: IRET
    INTEGER :: IPITCH_DST, IPITCH_SRC
    INTEGER(KIND=C_SIZE_T) :: IWIDTH, IHEIGHT, ISHP_SRC(3), ISHP_DST(3)
    INTEGER(KIND=C_SIZE_T) :: ISTRIDES_SRC(3), ISTRIDES_DST(3)
    INTEGER(KIND=CUDA_STREAM_KIND) :: STREAM
    TYPE(C_PTR) :: HSTPTR
    TYPE(C_DEVPTR) :: DEVPTR

    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_8(DST, 0)
    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_8(SRC, 0)
    NEXT_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_8(DST, LAST_CONTIG_DIM_DST+1)
    NEXT_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_8(SRC, LAST_CONTIG_DIM_SRC+1)

    ! We expect that device is always contiguous, and that host has only one non-contiguous dimension
    IF (KDIR == NH2D) THEN
      IF (LAST_CONTIG_DIM_DST /= 2) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_SRC /= 2) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_SRC
    ELSE IF (KDIR == ND2H) THEN
      IF (LAST_CONTIG_DIM_SRC /= 2) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_DST /= 2) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_DST
    ENDIF


    ISTRIDES_SRC(1) = LOC (SRC(LBOUND(SRC, 1)+1, LBOUND(SRC, 2))) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2)))
    ISTRIDES_DST(1) = LOC (DST(LBOUND(DST, 1)+1, LBOUND(DST, 2))) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2)))

    ISTRIDES_SRC(2) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2)+1)) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2)))
    ISTRIDES_DST(2) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2)+1)) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2)))

    ISTRIDES_SRC(3) = ISTRIDES_SRC(2) * SIZE(SRC, 2)
    ISTRIDES_DST(3) = ISTRIDES_DST(2) * SIZE(DST, 2)

    ISHP_SRC(1) = 1
    ISHP_SRC(2:) = SHAPE(SRC)
    ISHP_DST(1) = 1
    ISHP_DST(2:) = SHAPE(DST)
    IWIDTH = PRODUCT(ISHP_DST(1:LAST_CONTIG_DIM+1)) * KIND(DST)
    IHEIGHT = PRODUCT(ISHP_DST(LAST_CONTIG_DIM+2:NEXT_CONTIG_DIM_SRC+1))

    IPITCH_SRC = ISTRIDES_SRC(LAST_CONTIG_DIM+1)
    IPITCH_DST = ISTRIDES_DST(LAST_CONTIG_DIM+1)

    IF (KDIR == NH2D) THEN
      HSTPTR = C_LOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2)))
      !$ACC HOST_DATA USE_DEVICE(DST)
      DEVPTR = C_DEVLOC(DST(LBOUND(DST, 1),LBOUND(DST, 2)))
      !$ACC END HOST_DATA
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(DEVPTR, IPITCH_DST, &
                               & HSTPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(DEVPTR, IPITCH_DST, &
                          & HSTPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in H2D")
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      DEVPTR = C_DEVLOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2)))
      !$ACC END HOST_DATA
      HSTPTR = C_LOC(DST(LBOUND(DST, 1),LBOUND(DST, 2)))
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(HSTPTR, IPITCH_DST, &
                               & DEVPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(HSTPTR, IPITCH_DST, &
                          & DEVPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in D2H")
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_3_REAL_4(DST, SRC, KDIR, QUEUE)
    REAL(4), TARGET :: DST(:,:,:), SRC(:,:,:)
    REAL(4), POINTER :: DST_PTR(:,:,:), SRC_PTR(:,:,:)
    INTEGER (KIND=4), INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC

    SRC_PTR => SRC
    DST_PTR => DST

    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_4(SRC_PTR, 0)
    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_4(DST_PTR, 0)

    IF (LAST_CONTIG_DIM_SRC == 3 .AND. LAST_CONTIG_DIM_DST == 3) THEN
      CALL COPY_3_REAL_4_1D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ELSE
      CALL COPY_3_REAL_4_2D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_3_REAL_4_1D(DST, SRC, KDIR, QUEUE)
    REAL(4), CONTIGUOUS, POINTER :: DST (:,:,:), SRC (:,:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE

    INTEGER (KIND=C_SIZE_T) :: ISIZE

    ISIZE = KIND (DST) * SIZE(DST(:,:,:), KIND=C_SIZE_T)

    IF (KDIR == NH2D) THEN
      !$ACC HOST_DATA USE_DEVICE(DST)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_TO_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_TO_DEVICE(DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_FROM_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_FROM_DEVICE (DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ENDIF

  END SUBROUTINE
  SUBROUTINE COPY_3_REAL_4_2D(DST, SRC, KDIR, QUEUE)
    REAL(4), POINTER :: DST (:,:,:), SRC (:,:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC
    INTEGER :: NEXT_CONTIG_DIM_DST, NEXT_CONTIG_DIM_SRC

    INTEGER :: LAST_CONTIG_DIM

    INTEGER :: IRET
    INTEGER :: IPITCH_DST, IPITCH_SRC
    INTEGER(KIND=C_SIZE_T) :: IWIDTH, IHEIGHT, ISHP_SRC(4), ISHP_DST(4)
    INTEGER(KIND=C_SIZE_T) :: ISTRIDES_SRC(4), ISTRIDES_DST(4)
    INTEGER(KIND=CUDA_STREAM_KIND) :: STREAM
    TYPE(C_PTR) :: HSTPTR
    TYPE(C_DEVPTR) :: DEVPTR

    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_4(DST, 0)
    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_4(SRC, 0)
    NEXT_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_4(DST, LAST_CONTIG_DIM_DST+1)
    NEXT_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_4(SRC, LAST_CONTIG_DIM_SRC+1)

    ! We expect that device is always contiguous, and that host has only one non-contiguous dimension
    IF (KDIR == NH2D) THEN
      IF (LAST_CONTIG_DIM_DST /= 3) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_SRC /= 3) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_SRC
    ELSE IF (KDIR == ND2H) THEN
      IF (LAST_CONTIG_DIM_SRC /= 3) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_DST /= 3) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_DST
    ENDIF


    ISTRIDES_SRC(1) = LOC (SRC(LBOUND(SRC, 1)+1, LBOUND(SRC, 2), LBOUND(SRC, 3))) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2),&
        & LBOUND(SRC, 3)))
    ISTRIDES_DST(1) = LOC (DST(LBOUND(DST, 1)+1, LBOUND(DST, 2), LBOUND(DST, 3))) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2),&
        & LBOUND(DST, 3)))

    ISTRIDES_SRC(2) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2)+1, LBOUND(SRC, 3))) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2),&
        & LBOUND(SRC, 3)))
    ISTRIDES_DST(2) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2)+1, LBOUND(DST, 3))) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2),&
        & LBOUND(DST, 3)))

    ISTRIDES_SRC(3) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2), LBOUND(SRC, 3)+1)) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2),&
        & LBOUND(SRC, 3)))
    ISTRIDES_DST(3) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2), LBOUND(DST, 3)+1)) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2),&
        & LBOUND(DST, 3)))

    ISTRIDES_SRC(4) = ISTRIDES_SRC(3) * SIZE(SRC, 3)
    ISTRIDES_DST(4) = ISTRIDES_DST(3) * SIZE(DST, 3)

    ISHP_SRC(1) = 1
    ISHP_SRC(2:) = SHAPE(SRC)
    ISHP_DST(1) = 1
    ISHP_DST(2:) = SHAPE(DST)
    IWIDTH = PRODUCT(ISHP_DST(1:LAST_CONTIG_DIM+1)) * KIND(DST)
    IHEIGHT = PRODUCT(ISHP_DST(LAST_CONTIG_DIM+2:NEXT_CONTIG_DIM_SRC+1))

    IPITCH_SRC = ISTRIDES_SRC(LAST_CONTIG_DIM+1)
    IPITCH_DST = ISTRIDES_DST(LAST_CONTIG_DIM+1)

    IF (KDIR == NH2D) THEN
      HSTPTR = C_LOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2),LBOUND(SRC, 3)))
      !$ACC HOST_DATA USE_DEVICE(DST)
      DEVPTR = C_DEVLOC(DST(LBOUND(DST, 1),LBOUND(DST, 2),LBOUND(DST, 3)))
      !$ACC END HOST_DATA
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(DEVPTR, IPITCH_DST, &
                               & HSTPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(DEVPTR, IPITCH_DST, &
                          & HSTPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in H2D")
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      DEVPTR = C_DEVLOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2),LBOUND(SRC, 3)))
      !$ACC END HOST_DATA
      HSTPTR = C_LOC(DST(LBOUND(DST, 1),LBOUND(DST, 2),LBOUND(DST, 3)))
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(HSTPTR, IPITCH_DST, &
                               & DEVPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(HSTPTR, IPITCH_DST, &
                          & DEVPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in D2H")
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_3_REAL_8(DST, SRC, KDIR, QUEUE)
    REAL(8), TARGET :: DST(:,:,:), SRC(:,:,:)
    REAL(8), POINTER :: DST_PTR(:,:,:), SRC_PTR(:,:,:)
    INTEGER (KIND=4), INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC

    SRC_PTR => SRC
    DST_PTR => DST

    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_8(SRC_PTR, 0)
    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_8(DST_PTR, 0)

    IF (LAST_CONTIG_DIM_SRC == 3 .AND. LAST_CONTIG_DIM_DST == 3) THEN
      CALL COPY_3_REAL_8_1D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ELSE
      CALL COPY_3_REAL_8_2D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_3_REAL_8_1D(DST, SRC, KDIR, QUEUE)
    REAL(8), CONTIGUOUS, POINTER :: DST (:,:,:), SRC (:,:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE

    INTEGER (KIND=C_SIZE_T) :: ISIZE

    ISIZE = KIND (DST) * SIZE(DST(:,:,:), KIND=C_SIZE_T)

    IF (KDIR == NH2D) THEN
      !$ACC HOST_DATA USE_DEVICE(DST)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_TO_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_TO_DEVICE(DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_FROM_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_FROM_DEVICE (DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ENDIF

  END SUBROUTINE
  SUBROUTINE COPY_3_REAL_8_2D(DST, SRC, KDIR, QUEUE)
    REAL(8), POINTER :: DST (:,:,:), SRC (:,:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC
    INTEGER :: NEXT_CONTIG_DIM_DST, NEXT_CONTIG_DIM_SRC

    INTEGER :: LAST_CONTIG_DIM

    INTEGER :: IRET
    INTEGER :: IPITCH_DST, IPITCH_SRC
    INTEGER(KIND=C_SIZE_T) :: IWIDTH, IHEIGHT, ISHP_SRC(4), ISHP_DST(4)
    INTEGER(KIND=C_SIZE_T) :: ISTRIDES_SRC(4), ISTRIDES_DST(4)
    INTEGER(KIND=CUDA_STREAM_KIND) :: STREAM
    TYPE(C_PTR) :: HSTPTR
    TYPE(C_DEVPTR) :: DEVPTR

    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_8(DST, 0)
    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_8(SRC, 0)
    NEXT_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_8(DST, LAST_CONTIG_DIM_DST+1)
    NEXT_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_8(SRC, LAST_CONTIG_DIM_SRC+1)

    ! We expect that device is always contiguous, and that host has only one non-contiguous dimension
    IF (KDIR == NH2D) THEN
      IF (LAST_CONTIG_DIM_DST /= 3) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_SRC /= 3) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_SRC
    ELSE IF (KDIR == ND2H) THEN
      IF (LAST_CONTIG_DIM_SRC /= 3) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_DST /= 3) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_DST
    ENDIF


    ISTRIDES_SRC(1) = LOC (SRC(LBOUND(SRC, 1)+1, LBOUND(SRC, 2), LBOUND(SRC, 3))) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2),&
        & LBOUND(SRC, 3)))
    ISTRIDES_DST(1) = LOC (DST(LBOUND(DST, 1)+1, LBOUND(DST, 2), LBOUND(DST, 3))) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2),&
        & LBOUND(DST, 3)))

    ISTRIDES_SRC(2) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2)+1, LBOUND(SRC, 3))) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2),&
        & LBOUND(SRC, 3)))
    ISTRIDES_DST(2) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2)+1, LBOUND(DST, 3))) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2),&
        & LBOUND(DST, 3)))

    ISTRIDES_SRC(3) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2), LBOUND(SRC, 3)+1)) - LOC (SRC (LBOUND(SRC, 1), LBOUND(SRC, 2),&
        & LBOUND(SRC, 3)))
    ISTRIDES_DST(3) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2), LBOUND(DST, 3)+1)) - LOC (DST (LBOUND(DST, 1), LBOUND(DST, 2),&
        & LBOUND(DST, 3)))

    ISTRIDES_SRC(4) = ISTRIDES_SRC(3) * SIZE(SRC, 3)
    ISTRIDES_DST(4) = ISTRIDES_DST(3) * SIZE(DST, 3)

    ISHP_SRC(1) = 1
    ISHP_SRC(2:) = SHAPE(SRC)
    ISHP_DST(1) = 1
    ISHP_DST(2:) = SHAPE(DST)
    IWIDTH = PRODUCT(ISHP_DST(1:LAST_CONTIG_DIM+1)) * KIND(DST)
    IHEIGHT = PRODUCT(ISHP_DST(LAST_CONTIG_DIM+2:NEXT_CONTIG_DIM_SRC+1))

    IPITCH_SRC = ISTRIDES_SRC(LAST_CONTIG_DIM+1)
    IPITCH_DST = ISTRIDES_DST(LAST_CONTIG_DIM+1)

    IF (KDIR == NH2D) THEN
      HSTPTR = C_LOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2),LBOUND(SRC, 3)))
      !$ACC HOST_DATA USE_DEVICE(DST)
      DEVPTR = C_DEVLOC(DST(LBOUND(DST, 1),LBOUND(DST, 2),LBOUND(DST, 3)))
      !$ACC END HOST_DATA
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(DEVPTR, IPITCH_DST, &
                               & HSTPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(DEVPTR, IPITCH_DST, &
                          & HSTPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in H2D")
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      DEVPTR = C_DEVLOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2),LBOUND(SRC, 3)))
      !$ACC END HOST_DATA
      HSTPTR = C_LOC(DST(LBOUND(DST, 1),LBOUND(DST, 2),LBOUND(DST, 3)))
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(HSTPTR, IPITCH_DST, &
                               & DEVPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(HSTPTR, IPITCH_DST, &
                          & DEVPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in D2H")
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_4_REAL_4(DST, SRC, KDIR, QUEUE)
    REAL(4), TARGET :: DST(:,:,:,:), SRC(:,:,:,:)
    REAL(4), POINTER :: DST_PTR(:,:,:,:), SRC_PTR(:,:,:,:)
    INTEGER (KIND=4), INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC

    SRC_PTR => SRC
    DST_PTR => DST

    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_4(SRC_PTR, 0)
    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_4(DST_PTR, 0)

    IF (LAST_CONTIG_DIM_SRC == 4 .AND. LAST_CONTIG_DIM_DST == 4) THEN
      CALL COPY_4_REAL_4_1D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ELSE
      CALL COPY_4_REAL_4_2D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_4_REAL_4_1D(DST, SRC, KDIR, QUEUE)
    REAL(4), CONTIGUOUS, POINTER :: DST (:,:,:,:), SRC (:,:,:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE

    INTEGER (KIND=C_SIZE_T) :: ISIZE

    ISIZE = KIND (DST) * SIZE(DST(:,:,:,:), KIND=C_SIZE_T)

    IF (KDIR == NH2D) THEN
      !$ACC HOST_DATA USE_DEVICE(DST)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_TO_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_TO_DEVICE(DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_FROM_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_FROM_DEVICE (DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ENDIF

  END SUBROUTINE
  SUBROUTINE COPY_4_REAL_4_2D(DST, SRC, KDIR, QUEUE)
    REAL(4), POINTER :: DST (:,:,:,:), SRC (:,:,:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC
    INTEGER :: NEXT_CONTIG_DIM_DST, NEXT_CONTIG_DIM_SRC

    INTEGER :: LAST_CONTIG_DIM

    INTEGER :: IRET
    INTEGER :: IPITCH_DST, IPITCH_SRC
    INTEGER(KIND=C_SIZE_T) :: IWIDTH, IHEIGHT, ISHP_SRC(5), ISHP_DST(5)
    INTEGER(KIND=C_SIZE_T) :: ISTRIDES_SRC(5), ISTRIDES_DST(5)
    INTEGER(KIND=CUDA_STREAM_KIND) :: STREAM
    TYPE(C_PTR) :: HSTPTR
    TYPE(C_DEVPTR) :: DEVPTR

    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_4(DST, 0)
    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_4(SRC, 0)
    NEXT_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_4(DST, LAST_CONTIG_DIM_DST+1)
    NEXT_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_4(SRC, LAST_CONTIG_DIM_SRC+1)

    ! We expect that device is always contiguous, and that host has only one non-contiguous dimension
    IF (KDIR == NH2D) THEN
      IF (LAST_CONTIG_DIM_DST /= 4) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_SRC /= 4) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_SRC
    ELSE IF (KDIR == ND2H) THEN
      IF (LAST_CONTIG_DIM_SRC /= 4) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_DST /= 4) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_DST
    ENDIF


    ISTRIDES_SRC(1) = LOC (SRC(LBOUND(SRC, 1)+1, LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4))) - LOC (SRC (LBOUND(SRC, 1),&
        & LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)))
    ISTRIDES_DST(1) = LOC (DST(LBOUND(DST, 1)+1, LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4))) - LOC (DST (LBOUND(DST, 1),&
        & LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)))

    ISTRIDES_SRC(2) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2)+1, LBOUND(SRC, 3), LBOUND(SRC, 4))) - LOC (SRC (LBOUND(SRC, 1),&
        & LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)))
    ISTRIDES_DST(2) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2)+1, LBOUND(DST, 3), LBOUND(DST, 4))) - LOC (DST (LBOUND(DST, 1),&
        & LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)))

    ISTRIDES_SRC(3) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2), LBOUND(SRC, 3)+1, LBOUND(SRC, 4))) - LOC (SRC (LBOUND(SRC, 1),&
        & LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)))
    ISTRIDES_DST(3) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2), LBOUND(DST, 3)+1, LBOUND(DST, 4))) - LOC (DST (LBOUND(DST, 1),&
        & LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)))

    ISTRIDES_SRC(4) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)+1)) - LOC (SRC (LBOUND(SRC, 1),&
        & LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)))
    ISTRIDES_DST(4) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)+1)) - LOC (DST (LBOUND(DST, 1),&
        & LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)))

    ISTRIDES_SRC(5) = ISTRIDES_SRC(4) * SIZE(SRC, 4)
    ISTRIDES_DST(5) = ISTRIDES_DST(4) * SIZE(DST, 4)

    ISHP_SRC(1) = 1
    ISHP_SRC(2:) = SHAPE(SRC)
    ISHP_DST(1) = 1
    ISHP_DST(2:) = SHAPE(DST)
    IWIDTH = PRODUCT(ISHP_DST(1:LAST_CONTIG_DIM+1)) * KIND(DST)
    IHEIGHT = PRODUCT(ISHP_DST(LAST_CONTIG_DIM+2:NEXT_CONTIG_DIM_SRC+1))

    IPITCH_SRC = ISTRIDES_SRC(LAST_CONTIG_DIM+1)
    IPITCH_DST = ISTRIDES_DST(LAST_CONTIG_DIM+1)

    IF (KDIR == NH2D) THEN
      HSTPTR = C_LOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2),LBOUND(SRC, 3),LBOUND(SRC, 4)))
      !$ACC HOST_DATA USE_DEVICE(DST)
      DEVPTR = C_DEVLOC(DST(LBOUND(DST, 1),LBOUND(DST, 2),LBOUND(DST, 3),LBOUND(DST, 4)))
      !$ACC END HOST_DATA
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(DEVPTR, IPITCH_DST, &
                               & HSTPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(DEVPTR, IPITCH_DST, &
                          & HSTPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in H2D")
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      DEVPTR = C_DEVLOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2),LBOUND(SRC, 3),LBOUND(SRC, 4)))
      !$ACC END HOST_DATA
      HSTPTR = C_LOC(DST(LBOUND(DST, 1),LBOUND(DST, 2),LBOUND(DST, 3),LBOUND(DST, 4)))
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(HSTPTR, IPITCH_DST, &
                               & DEVPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(HSTPTR, IPITCH_DST, &
                          & DEVPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in D2H")
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_4_REAL_8(DST, SRC, KDIR, QUEUE)
    REAL(8), TARGET :: DST(:,:,:,:), SRC(:,:,:,:)
    REAL(8), POINTER :: DST_PTR(:,:,:,:), SRC_PTR(:,:,:,:)
    INTEGER (KIND=4), INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC

    SRC_PTR => SRC
    DST_PTR => DST

    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_8(SRC_PTR, 0)
    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_8(DST_PTR, 0)

    IF (LAST_CONTIG_DIM_SRC == 4 .AND. LAST_CONTIG_DIM_DST == 4) THEN
      CALL COPY_4_REAL_8_1D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ELSE
      CALL COPY_4_REAL_8_2D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_4_REAL_8_1D(DST, SRC, KDIR, QUEUE)
    REAL(8), CONTIGUOUS, POINTER :: DST (:,:,:,:), SRC (:,:,:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE

    INTEGER (KIND=C_SIZE_T) :: ISIZE

    ISIZE = KIND (DST) * SIZE(DST(:,:,:,:), KIND=C_SIZE_T)

    IF (KDIR == NH2D) THEN
      !$ACC HOST_DATA USE_DEVICE(DST)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_TO_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_TO_DEVICE(DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_FROM_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_FROM_DEVICE (DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ENDIF

  END SUBROUTINE
  SUBROUTINE COPY_4_REAL_8_2D(DST, SRC, KDIR, QUEUE)
    REAL(8), POINTER :: DST (:,:,:,:), SRC (:,:,:,:)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC
    INTEGER :: NEXT_CONTIG_DIM_DST, NEXT_CONTIG_DIM_SRC

    INTEGER :: LAST_CONTIG_DIM

    INTEGER :: IRET
    INTEGER :: IPITCH_DST, IPITCH_SRC
    INTEGER(KIND=C_SIZE_T) :: IWIDTH, IHEIGHT, ISHP_SRC(5), ISHP_DST(5)
    INTEGER(KIND=C_SIZE_T) :: ISTRIDES_SRC(5), ISTRIDES_DST(5)
    INTEGER(KIND=CUDA_STREAM_KIND) :: STREAM
    TYPE(C_PTR) :: HSTPTR
    TYPE(C_DEVPTR) :: DEVPTR

    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_8(DST, 0)
    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_8(SRC, 0)
    NEXT_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_8(DST, LAST_CONTIG_DIM_DST+1)
    NEXT_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_8(SRC, LAST_CONTIG_DIM_SRC+1)

    ! We expect that device is always contiguous, and that host has only one non-contiguous dimension
    IF (KDIR == NH2D) THEN
      IF (LAST_CONTIG_DIM_DST /= 4) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_SRC /= 4) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_SRC
    ELSE IF (KDIR == ND2H) THEN
      IF (LAST_CONTIG_DIM_SRC /= 4) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_DST /= 4) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_DST
    ENDIF


    ISTRIDES_SRC(1) = LOC (SRC(LBOUND(SRC, 1)+1, LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4))) - LOC (SRC (LBOUND(SRC, 1),&
        & LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)))
    ISTRIDES_DST(1) = LOC (DST(LBOUND(DST, 1)+1, LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4))) - LOC (DST (LBOUND(DST, 1),&
        & LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)))

    ISTRIDES_SRC(2) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2)+1, LBOUND(SRC, 3), LBOUND(SRC, 4))) - LOC (SRC (LBOUND(SRC, 1),&
        & LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)))
    ISTRIDES_DST(2) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2)+1, LBOUND(DST, 3), LBOUND(DST, 4))) - LOC (DST (LBOUND(DST, 1),&
        & LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)))

    ISTRIDES_SRC(3) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2), LBOUND(SRC, 3)+1, LBOUND(SRC, 4))) - LOC (SRC (LBOUND(SRC, 1),&
        & LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)))
    ISTRIDES_DST(3) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2), LBOUND(DST, 3)+1, LBOUND(DST, 4))) - LOC (DST (LBOUND(DST, 1),&
        & LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)))

    ISTRIDES_SRC(4) = LOC (SRC(LBOUND(SRC, 1), LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)+1)) - LOC (SRC (LBOUND(SRC, 1),&
        & LBOUND(SRC, 2), LBOUND(SRC, 3), LBOUND(SRC, 4)))
    ISTRIDES_DST(4) = LOC (DST(LBOUND(DST, 1), LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)+1)) - LOC (DST (LBOUND(DST, 1),&
        & LBOUND(DST, 2), LBOUND(DST, 3), LBOUND(DST, 4)))

    ISTRIDES_SRC(5) = ISTRIDES_SRC(4) * SIZE(SRC, 4)
    ISTRIDES_DST(5) = ISTRIDES_DST(4) * SIZE(DST, 4)

    ISHP_SRC(1) = 1
    ISHP_SRC(2:) = SHAPE(SRC)
    ISHP_DST(1) = 1
    ISHP_DST(2:) = SHAPE(DST)
    IWIDTH = PRODUCT(ISHP_DST(1:LAST_CONTIG_DIM+1)) * KIND(DST)
    IHEIGHT = PRODUCT(ISHP_DST(LAST_CONTIG_DIM+2:NEXT_CONTIG_DIM_SRC+1))

    IPITCH_SRC = ISTRIDES_SRC(LAST_CONTIG_DIM+1)
    IPITCH_DST = ISTRIDES_DST(LAST_CONTIG_DIM+1)

    IF (KDIR == NH2D) THEN
      HSTPTR = C_LOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2),LBOUND(SRC, 3),LBOUND(SRC, 4)))
      !$ACC HOST_DATA USE_DEVICE(DST)
      DEVPTR = C_DEVLOC(DST(LBOUND(DST, 1),LBOUND(DST, 2),LBOUND(DST, 3),LBOUND(DST, 4)))
      !$ACC END HOST_DATA
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(DEVPTR, IPITCH_DST, &
                               & HSTPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(DEVPTR, IPITCH_DST, &
                          & HSTPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in H2D")
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      DEVPTR = C_DEVLOC(SRC(LBOUND(SRC, 1),LBOUND(SRC, 2),LBOUND(SRC, 3),LBOUND(SRC, 4)))
      !$ACC END HOST_DATA
      HSTPTR = C_LOC(DST(LBOUND(DST, 1),LBOUND(DST, 2),LBOUND(DST, 3),LBOUND(DST, 4)))
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_CUDA_STREAM(QUEUE)
        IRET = CUDAMEMCPY2DASYNC(HSTPTR, IPITCH_DST, &
                               & DEVPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = CUDAMEMCPY2D(HSTPTR, IPITCH_DST, &
                          & DEVPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in D2H")
    ENDIF
  END SUBROUTINE



  INTEGER FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_4(PTR, AFTER) RESULT (JDIM)
  REAL(4), POINTER :: PTR (:,:)
  INTEGER :: AFTER
  INTEGER(KIND=C_SIZE_T) :: IPREVIOUS_STRIDE, ITHIS_STRIDE, ISIZE
  INTEGER :: J, LB(2)

  ! assume that dimension all dimensions before AFTER are contiguous...

  LB = LBOUND(PTR)
  IF (AFTER == 0) THEN
    IPREVIOUS_STRIDE = KIND (PTR)
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1)+1, LB(2))) - LOC (PTR (LB(1), LB(2)))
  IF (AFTER < 1) THEN
    ISIZE = 1
    IF (SIZE(PTR, 1) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 0
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 1) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2)+1)) - LOC (PTR (LB(1), LB(2)))
  IF (AFTER < 2) THEN
    ISIZE = SIZE(PTR, 1)
    IF (SIZE(PTR, 2) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 1
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 2) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  JDIM = 2
  END FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_4


  INTEGER FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_8(PTR, AFTER) RESULT (JDIM)
  REAL(8), POINTER :: PTR (:,:)
  INTEGER :: AFTER
  INTEGER(KIND=C_SIZE_T) :: IPREVIOUS_STRIDE, ITHIS_STRIDE, ISIZE
  INTEGER :: J, LB(2)

  ! assume that dimension all dimensions before AFTER are contiguous...

  LB = LBOUND(PTR)
  IF (AFTER == 0) THEN
    IPREVIOUS_STRIDE = KIND (PTR)
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1)+1, LB(2))) - LOC (PTR (LB(1), LB(2)))
  IF (AFTER < 1) THEN
    ISIZE = 1
    IF (SIZE(PTR, 1) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 0
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 1) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2)+1)) - LOC (PTR (LB(1), LB(2)))
  IF (AFTER < 2) THEN
    ISIZE = SIZE(PTR, 1)
    IF (SIZE(PTR, 2) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 1
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 2) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  JDIM = 2
  END FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_2_REAL_8


  INTEGER FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_4(PTR, AFTER) RESULT (JDIM)
  REAL(4), POINTER :: PTR (:,:,:)
  INTEGER :: AFTER
  INTEGER(KIND=C_SIZE_T) :: IPREVIOUS_STRIDE, ITHIS_STRIDE, ISIZE
  INTEGER :: J, LB(3)

  ! assume that dimension all dimensions before AFTER are contiguous...

  LB = LBOUND(PTR)
  IF (AFTER == 0) THEN
    IPREVIOUS_STRIDE = KIND (PTR)
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1)+1, LB(2), LB(3))) - LOC (PTR (LB(1), LB(2), LB(3)))
  IF (AFTER < 1) THEN
    ISIZE = 1
    IF (SIZE(PTR, 1) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 0
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 1) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2)+1, LB(3))) - LOC (PTR (LB(1), LB(2), LB(3)))
  IF (AFTER < 2) THEN
    ISIZE = SIZE(PTR, 1)
    IF (SIZE(PTR, 2) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 1
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 2) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2), LB(3)+1)) - LOC (PTR (LB(1), LB(2), LB(3)))
  IF (AFTER < 3) THEN
    ISIZE = SIZE(PTR, 2)
    IF (SIZE(PTR, 3) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 2
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 3) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  JDIM = 3
  END FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_4


  INTEGER FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_8(PTR, AFTER) RESULT (JDIM)
  REAL(8), POINTER :: PTR (:,:,:)
  INTEGER :: AFTER
  INTEGER(KIND=C_SIZE_T) :: IPREVIOUS_STRIDE, ITHIS_STRIDE, ISIZE
  INTEGER :: J, LB(3)

  ! assume that dimension all dimensions before AFTER are contiguous...

  LB = LBOUND(PTR)
  IF (AFTER == 0) THEN
    IPREVIOUS_STRIDE = KIND (PTR)
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1)+1, LB(2), LB(3))) - LOC (PTR (LB(1), LB(2), LB(3)))
  IF (AFTER < 1) THEN
    ISIZE = 1
    IF (SIZE(PTR, 1) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 0
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 1) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2)+1, LB(3))) - LOC (PTR (LB(1), LB(2), LB(3)))
  IF (AFTER < 2) THEN
    ISIZE = SIZE(PTR, 1)
    IF (SIZE(PTR, 2) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 1
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 2) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2), LB(3)+1)) - LOC (PTR (LB(1), LB(2), LB(3)))
  IF (AFTER < 3) THEN
    ISIZE = SIZE(PTR, 2)
    IF (SIZE(PTR, 3) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 2
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 3) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  JDIM = 3
  END FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_3_REAL_8


  INTEGER FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_4(PTR, AFTER) RESULT (JDIM)
  REAL(4), POINTER :: PTR (:,:,:,:)
  INTEGER :: AFTER
  INTEGER(KIND=C_SIZE_T) :: IPREVIOUS_STRIDE, ITHIS_STRIDE, ISIZE
  INTEGER :: J, LB(4)

  ! assume that dimension all dimensions before AFTER are contiguous...

  LB = LBOUND(PTR)
  IF (AFTER == 0) THEN
    IPREVIOUS_STRIDE = KIND (PTR)
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1)+1, LB(2), LB(3), LB(4))) - LOC (PTR (LB(1), LB(2), LB(3), LB(4)))
  IF (AFTER < 1) THEN
    ISIZE = 1
    IF (SIZE(PTR, 1) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 0
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 1) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2)+1, LB(3), LB(4))) - LOC (PTR (LB(1), LB(2), LB(3), LB(4)))
  IF (AFTER < 2) THEN
    ISIZE = SIZE(PTR, 1)
    IF (SIZE(PTR, 2) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 1
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 2) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2), LB(3)+1, LB(4))) - LOC (PTR (LB(1), LB(2), LB(3), LB(4)))
  IF (AFTER < 3) THEN
    ISIZE = SIZE(PTR, 2)
    IF (SIZE(PTR, 3) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 2
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 3) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2), LB(3), LB(4)+1)) - LOC (PTR (LB(1), LB(2), LB(3), LB(4)))
  IF (AFTER < 4) THEN
    ISIZE = SIZE(PTR, 3)
    IF (SIZE(PTR, 4) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 3
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 4) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  JDIM = 4
  END FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_4


  INTEGER FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_8(PTR, AFTER) RESULT (JDIM)
  REAL(8), POINTER :: PTR (:,:,:,:)
  INTEGER :: AFTER
  INTEGER(KIND=C_SIZE_T) :: IPREVIOUS_STRIDE, ITHIS_STRIDE, ISIZE
  INTEGER :: J, LB(4)

  ! assume that dimension all dimensions before AFTER are contiguous...

  LB = LBOUND(PTR)
  IF (AFTER == 0) THEN
    IPREVIOUS_STRIDE = KIND (PTR)
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1)+1, LB(2), LB(3), LB(4))) - LOC (PTR (LB(1), LB(2), LB(3), LB(4)))
  IF (AFTER < 1) THEN
    ISIZE = 1
    IF (SIZE(PTR, 1) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 0
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 1) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2)+1, LB(3), LB(4))) - LOC (PTR (LB(1), LB(2), LB(3), LB(4)))
  IF (AFTER < 2) THEN
    ISIZE = SIZE(PTR, 1)
    IF (SIZE(PTR, 2) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 1
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 2) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2), LB(3)+1, LB(4))) - LOC (PTR (LB(1), LB(2), LB(3), LB(4)))
  IF (AFTER < 3) THEN
    ISIZE = SIZE(PTR, 2)
    IF (SIZE(PTR, 3) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 2
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 3) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  ITHIS_STRIDE = LOC (PTR (LB(1), LB(2), LB(3), LB(4)+1)) - LOC (PTR (LB(1), LB(2), LB(3), LB(4)))
  IF (AFTER < 4) THEN
    ISIZE = SIZE(PTR, 3)
    IF (SIZE(PTR, 4) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = 3
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == 4) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

  JDIM = 4
  END FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_4_REAL_8


END MODULE CUDA_COPY_MODULE
