#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#! (C) Copyright 2023- NVIDIA
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

#! fypp cuda_copy_module.fypp -m collections -m itertools > cuda_copy_module.F90

#:set shape = lambda rank : ','.join([':'] * rank)
#:set function_name = lambda dt: str(dt.type).upper() + '_' + str(dt.kind).upper()

#ifdef HIPGPU
#define GPUFOR HIPFORT
#define HICMEMCPYDEVICETOHOST HIPMEMCPYDEVICETOHOST
#define HICMEMCPYHOSTTODEVICE HIPMEMCPYHOSTTODEVICE
#define HICMEMCPY2DASYNC HIPMEMCPY2DASYNC
#define HICMEMCPY2D HIPMEMCPY2D
#define HIC_STREAM_KIND HIP_STREAM_KIND
#define ACC_GET_HIC_STREAM ACC_GET_HIP_STREAM
#elif defined CUDAGPU
#define GPUFOR CUDAFOR
#define HICMEMCPYDEVICETOHOST CUDAMEMCPYDEVICETOHOST
#define HICMEMCPYHOSTTODEVICE CUDAMEMCPYHOSTTODEVICE
#define HICMEMCPY2DASYNC CUDAMEMCPY2DASYNC
#define HICMEMCPY2D CUDAMEMCPY2D
#define HIC_STREAM_KIND CUDA_STREAM_KIND
#define ACC_GET_HIC_STREAM ACC_GET_CUDA_STREAM
#endif

MODULE GPU_COPY_MODULE

USE OPENACC
USE GPUFOR
USE ISO_C_BINDING

#:set DataType = collections.namedtuple('DataType', ['type', 'kind'])

#:set fields = list(itertools.product(list(range(2, 5)), [DataType("real", "4"), DataType("real", "8")]))

IMPLICIT NONE

PRIVATE

PUBLIC :: COPY, NH2D, ND2H, ACC_HANDLE_KIND

INTEGER(4), PARAMETER :: NH2D = HICMEMCPYHOSTTODEVICE , ND2H = HICMEMCPYDEVICETOHOST

INTERFACE COPY
#:for rank, datatype in fields
MODULE PROCEDURE COPY_${rank}$_${function_name(datatype)}$
#:endfor
END INTERFACE

CONTAINS

#:for rank, datatype in fields
#:set ftn = f"{rank}_{function_name(datatype)}".upper()
#:set dt = f"{datatype.type}({datatype.kind})".upper()

  SUBROUTINE COPY_${ftn}$(DST, SRC, KDIR, QUEUE)
    ${dt}$, TARGET :: DST(${shape(rank)}$), SRC(${shape(rank)}$)
    ${dt}$, POINTER :: DST_PTR(${shape(rank)}$), SRC_PTR(${shape(rank)}$)
    INTEGER (KIND=4), INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC

    SRC_PTR => SRC
    DST_PTR => DST

    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_${ftn}$(SRC_PTR, 0)
    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_${ftn}$(DST_PTR, 0)

    IF (LAST_CONTIG_DIM_SRC == ${rank}$ .AND. LAST_CONTIG_DIM_DST == ${rank}$) THEN
      CALL COPY_${ftn}$_1D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ELSE
      CALL COPY_${ftn}$_2D(DST_PTR, SRC_PTR, KDIR, QUEUE)
    ENDIF
  END SUBROUTINE

  SUBROUTINE COPY_${ftn}$_1D(DST, SRC, KDIR, QUEUE)
    ${dt}$, CONTIGUOUS, POINTER :: DST (${shape(rank)}$), SRC (${shape(rank)}$)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE

    INTEGER (KIND=C_SIZE_T) :: ISIZE

    ISIZE = KIND (DST) * SIZE(DST(${','.join([':'] * rank)}$), KIND=C_SIZE_T)

#:if defined('DEBUG')
    PRINT *, "COPY_${ftn}$_1D"
    PRINT *, "SIZE", ISIZE

#:endif
    IF (KDIR == NH2D) THEN
      !$ACC HOST_DATA USE_DEVICE(DST)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_TO_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_TO_DEVICE(DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      IF(PRESENT(QUEUE))THEN
        CALL ACC_MEMCPY_FROM_DEVICE_ASYNC(DST, SRC, ISIZE, QUEUE)
      ELSE
        CALL ACC_MEMCPY_FROM_DEVICE (DST, SRC, ISIZE)
      ENDIF
      !$ACC END HOST_DATA
    ENDIF

  END SUBROUTINE
  SUBROUTINE COPY_${ftn}$_2D(DST, SRC, KDIR, QUEUE)
    ${dt}$, POINTER :: DST (${shape(rank)}$), SRC (${shape(rank)}$)
    INTEGER (KIND=4),           INTENT (IN) :: KDIR
    INTEGER (KIND=ACC_HANDLE_KIND), OPTIONAL, INTENT (IN) :: QUEUE
    INTEGER :: LAST_CONTIG_DIM_DST, LAST_CONTIG_DIM_SRC
    INTEGER :: NEXT_CONTIG_DIM_DST, NEXT_CONTIG_DIM_SRC

    INTEGER :: LAST_CONTIG_DIM

    INTEGER :: IRET
    INTEGER :: IPITCH_DST, IPITCH_SRC
    INTEGER(KIND=C_SIZE_T) :: IWIDTH, IHEIGHT, ISHP_SRC(${rank+1}$), ISHP_DST(${rank+1}$)
    INTEGER(KIND=C_SIZE_T) :: ISTRIDES_SRC(${rank+1}$), ISTRIDES_DST(${rank+1}$)
    INTEGER(KIND=HIC_STREAM_KIND) :: STREAM
    TYPE(C_PTR) :: HSTPTR
    TYPE(C_DEVPTR) :: DEVPTR

    LAST_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_${ftn}$(DST, 0)
    LAST_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_${ftn}$(SRC, 0)
    NEXT_CONTIG_DIM_DST = GET_LAST_CONTIGUOUS_DIMENSION_${ftn}$(DST, LAST_CONTIG_DIM_DST+1)
    NEXT_CONTIG_DIM_SRC = GET_LAST_CONTIGUOUS_DIMENSION_${ftn}$(SRC, LAST_CONTIG_DIM_SRC+1)

    ! We expect that device is always contiguous, and that host has only one non-contiguous dimension
    IF (KDIR == NH2D) THEN
      IF (LAST_CONTIG_DIM_DST /= ${rank}$) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_SRC /= ${rank}$) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_SRC
    ELSE IF (KDIR == ND2H) THEN
      IF (LAST_CONTIG_DIM_SRC /= ${rank}$) CALL ABOR1("device must be contiguous")
      IF (NEXT_CONTIG_DIM_DST /= ${rank}$) CALL ABOR1("host must have at most one non-cont dim")
      LAST_CONTIG_DIM = LAST_CONTIG_DIM_DST
    ENDIF

#:for d in range(rank)
#:set lb = lambda arr, i: f'LBOUND({arr}, {i+1})'
#:set lbnds = lambda arr, start, end: [lb(arr, i) for i in range(start, end)]
#:set this_slice = lambda arr: ', '.join(lbnds(arr, 0, rank))
#:set next_slice = lambda arr: ', '.join(lbnds(arr, 0, d) + [lb(arr, d)+'+1'] + lbnds(arr, d+1, rank))

    ISTRIDES_SRC(${d+1}$) = LOC (SRC(${next_slice('SRC')}$)) - LOC (SRC (${this_slice('SRC')}$))
    ISTRIDES_DST(${d+1}$) = LOC (DST(${next_slice('DST')}$)) - LOC (DST (${this_slice('DST')}$))
#:endfor

    ISTRIDES_SRC(${rank+1}$) = ISTRIDES_SRC(${rank}$) * SIZE(SRC, ${rank}$)
    ISTRIDES_DST(${rank+1}$) = ISTRIDES_DST(${rank}$) * SIZE(DST, ${rank}$)

    ISHP_SRC(1) = 1
    ISHP_SRC(2:) = SHAPE(SRC)
    ISHP_DST(1) = 1
    ISHP_DST(2:) = SHAPE(DST)
    IWIDTH = PRODUCT(ISHP_DST(1:LAST_CONTIG_DIM+1)) * KIND(DST)
    IHEIGHT = PRODUCT(ISHP_DST(LAST_CONTIG_DIM+2:NEXT_CONTIG_DIM_SRC+1))

    IPITCH_SRC = ISTRIDES_SRC(LAST_CONTIG_DIM+1)
    IPITCH_DST = ISTRIDES_DST(LAST_CONTIG_DIM+1)

#:if defined('DEBUG')
    PRINT *, "COPY_${ftn}$_2D"
    PRINT *, "IPITCH_SRC/DST", IPITCH_SRC, IPITCH_DST
    PRINT *, "IWIDTH/IHEIGHT", IWIDTH, IHEIGHT

#:endif
  #:set ar = lambda arr: ','.join(lbnds(arr, 0, rank))
    IF (KDIR == NH2D) THEN
      HSTPTR = C_LOC(SRC(${ar('SRC')}$))
      !$ACC HOST_DATA USE_DEVICE(DST)
      DEVPTR = C_DEVLOC(DST(${ar('DST')}$))
      !$ACC END HOST_DATA
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_HIC_STREAM(QUEUE)
        IRET = HICMEMCPY2DASYNC(DEVPTR, IPITCH_DST, &
                               & HSTPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = HICMEMCPY2D(DEVPTR, IPITCH_DST, &
                          & HSTPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in H2D")
    ELSEIF (KDIR == ND2H) THEN
      !$ACC HOST_DATA USE_DEVICE(SRC)
      DEVPTR = C_DEVLOC(SRC(${ar('SRC')}$))
      !$ACC END HOST_DATA
      HSTPTR = C_LOC(DST(${ar('DST')}$))
      IF(PRESENT(QUEUE)) THEN
        STREAM = ACC_GET_HIC_STREAM(QUEUE)
        IRET = HICMEMCPY2DASYNC(HSTPTR, IPITCH_DST, &
                               & DEVPTR, IPITCH_SRC, &
                               & IWIDTH, IHEIGHT, &
                               & STREAM=STREAM)
      ELSE
        IRET = HICMEMCPY2D(HSTPTR, IPITCH_DST, &
                          & DEVPTR, IPITCH_SRC, &
                          & IWIDTH, IHEIGHT)
      ENDIF
      IF (IRET /= CUDASUCCESS) CALL ABOR1("error in D2H")
    ENDIF
  END SUBROUTINE
#:endfor


#:for rank, datatype in fields
#:set ftn = f"{rank}_{function_name(datatype)}".upper()
#:set dt = f"{datatype.type}({datatype.kind})".upper()

  INTEGER FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_${ftn}$(PTR, AFTER) RESULT (JDIM)
  ${dt}$, POINTER :: PTR (${shape(rank)}$)
  INTEGER :: AFTER
  INTEGER(KIND=C_SIZE_T) :: IPREVIOUS_STRIDE, ITHIS_STRIDE, ISIZE
  INTEGER :: J, LB(${rank}$)

  ! assume that dimension all dimensions before AFTER are contiguous...

  LB = LBOUND(PTR)
  IF (AFTER == 0) THEN
    IPREVIOUS_STRIDE = KIND (PTR)
  ENDIF

#:for d in range (1, rank+1)
  #:set ind0 = ""
  #:set ind1 = ""
  #:for i in range(1,rank+1)
    #:set ind0 = ind0 + "LB({}), ".format(i)
    #:set ind1 = ind1 + "LB({}){}, ".format(i,"+1"*(i==d))
  #:endfor
  #:set ind0 = ind0[:-2]
  #:set ind1 = ind1[:-2]
  ITHIS_STRIDE = LOC (PTR (${ind1}$)) - LOC (PTR (${ind0}$))
  IF (AFTER < ${d}$) THEN
   #:if d == 1
    ISIZE = 1
   #:else
    ISIZE = SIZE(PTR, ${d-1}$)
   #:endif
    IF (SIZE(PTR, ${d}$) /= 1 .AND. IPREVIOUS_STRIDE * ISIZE /= ITHIS_STRIDE) THEN
      JDIM = ${d-1}$
      RETURN
    ENDIF
    IPREVIOUS_STRIDE = IPREVIOUS_STRIDE * ISIZE
  ELSE IF (AFTER == ${d}$) THEN
    IPREVIOUS_STRIDE = ITHIS_STRIDE
  ENDIF

#:endfor
  JDIM = ${rank}$
  END FUNCTION GET_LAST_CONTIGUOUS_DIMENSION_${ftn}$

#:endfor

END MODULE GPU_COPY_MODULE
